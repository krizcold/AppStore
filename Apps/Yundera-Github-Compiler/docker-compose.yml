name: yunderagithubcompiler

services:
  yunderagithubcompiler:
    image: krizcold/yundera-github-compiler:latest
    container_name: yunderagithubcompiler
    restart: unless-stopped
    expose:
      - "3000"
    user: "root"
    entrypoint: ["/bin/sh"]
    command:
      - -c
      - |
        npm run setup
    environment:
      # Application settings
      WEBUI_PORT: "3000"
      
      # CasaOS integration
      DEPLOYMENT_MODE: "appstore"
      CASAOS_API_HOST: "localhost"
      CASAOS_API_PORT: "8080"
      DATA_ROOT: $DATA_ROOT
      
      # Yundera platform integration
      DOMAIN: $DOMAIN
      PROVIDER_STR: $PROVIDER_STR
      UID: $UID
      DEFAULT_PWD: $DEFAULT_PWD
      PUBLIC_IP: $PUBLIC_IP
      DEFAULT_USER: $DEFAULT_USER
      
      # Authentication and paths
      JWT_SECRET: $JWT_SECRET
      AUTHORITY_ENDPOINT: $AUTHORITY_ENDPOINT
      COMPOSE_FOLDER_PATH: $COMPOSE_FOLDER_PATH
      BASE_PATH: $BASE_PATH
      MOCK: $MOCK
      
      # Pass through the host's CasaOS environment variables.
      # These will be populated by the AppStore during installation.
      PUID: $PUID
      PGID: $PGID
      REF_DOMAIN: $REF_DOMAIN
      REF_NET: $REF_NET
      REF_PORT: $REF_PORT
      REF_SCHEME: $REF_SCHEME
      REF_SEPARATOR: $REF_SEPARATOR
      
      # Debug/logging settings
      LOG_APPS_BEACON: $LOG_APPS_BEACON
      
      user: $user
      default_pwd: $default_pwd
      public_ip: $public_ip

    volumes:        
      # cloned repos
      - type: bind
        source: /DATA/AppData/yunderagithubcompiler/repos
        target: /app/repos

      # persistent UI data storage
      - type: bind
        source: /DATA/AppData/yunderagithubcompiler/uidata
        target: /app/uidata

      # Writable mount for app metadata
      - type: bind
        source: /DATA/AppData
        target: /DATA/AppData

      # Bind mount for the main app directory
      - type: bind
        source: /DATA/AppData/casaos/apps/yunderagithubcompiler
        target: /DATA/AppData/casaos/apps/yunderagithubcompiler
        read_only: true

      - type: bind
        source: /var/run/docker.sock
        target: /var/run/docker.sock

    # Connect to the same network as the CasaOS service
    networks:
      - pcs
    
    # Add privileges to access CasaOS data (similar to CasaOS container)
    privileged: true
    
    # Add capabilities
    cap_add:
      - SYS_ADMIN
      - NET_ADMIN

    x-casaos:
      volumes:
        - container: /app/repos
          description:
            en_us: "Git repos are cloned here."
        - container: /app/uidata
          description:
            en_us: "Persistent UI data storage."

# Define the network as external, since it's created by the main NSL stack
networks:
  pcs:
    external: true

x-casaos:
  architectures:
    - amd64
    - arm64
  main: yunderagithubcompiler
  author: krizcold
  developer: krizcold
  icon: https://github.com/krizcold/Yundera-Github-Compiler/blob/main/YunderaCompiler.png?raw=true
  tagline:
    en_us: "Automatically build and deploy GitHub repos on Yundera"
  category: Utilities
  description:
    en_us: "Clone, build, and run Docker-based projects directly from GitHub URLs."
  title:
    en_us: "Yundera GitHub Compiler"
  store_app_id: yunderagithubcompiler
  is_uncontrolled: false
  index: /
  webui_port: 3000
  pre-install-cmd: |
    # Generate the hash value that will be embedded into the background script.
    AUTH_HASH=$(openssl rand -hex 64)
    
    echo "üöÄ Yundera GitHub Compiler pre-install starting..."
    
    # Setup SSH access for pre-install commands with PROPER USER PERMISSIONS
    # Log everything to help debug failures
    SSH_SETUP_LOG="/tmp/yundera-ssh-setup-$(date +%Y%m%d-%H%M%S).log"
    echo "üîß Setting up SSH access with user-manageable permissions (logging to $SSH_SETUP_LOG)..."
    
    (
        echo "=== SSH Setup Started at $(date) ==="
        echo "Host: $(hostname)"
        echo "User: $(whoami)"
        echo "UID/GID: $(id)"
        echo "Working directory: $(pwd)"
        echo ""
        
        echo "üìÅ Fresh PCS installation - creating directory structure with proper permissions..."
        
        # Check if this is truly a fresh installation
        if [ -d "/DATA/AppData/yunderagithubcompiler" ]; then
            echo "‚ö†Ô∏è WARNING: yunderagithubcompiler directory already exists - checking ownership..."
            echo "   Existing: $(ls -ld /DATA/AppData/yunderagithubcompiler/ 2>/dev/null || echo 'cannot read')"
        fi
        
        # Step 1: Create yunderagithubcompiler directory with proper ownership from the start
        echo ""
        echo "üî® STEP 1: Creating yunderagithubcompiler directory with careful permissions..."
        
        # Create directory and immediately set ownership to prevent root ownership
        if mkdir -p /DATA/AppData/yunderagithubcompiler/ 2>/dev/null; then
            echo "   Directory created successfully"
        else
            echo "   Directory already exists"
        fi
        
        # Ensure proper ownership (ubuntu user with docker group)
        if chown ubuntu:988 /DATA/AppData/yunderagithubcompiler/ 2>/dev/null; then
            echo "‚úÖ Set yunderagithubcompiler ownership to ubuntu:988"
        else
            echo "‚ùå Cannot set yunderagithubcompiler ownership to ubuntu:988"
        fi
        
        # Set permissions
        if chmod 755 /DATA/AppData/yunderagithubcompiler/ 2>/dev/null; then
            echo "‚úÖ Set yunderagithubcompiler permissions to 755"
        else
            echo "‚ùå Cannot set yunderagithubcompiler permissions to 755"
        fi
        
        echo "   Final state: $(ls -ld /DATA/AppData/yunderagithubcompiler/ 2>/dev/null || echo 'FAILED')"
        
        # Test write access
        if touch /DATA/AppData/yunderagithubcompiler/.test_write 2>/dev/null; then
            rm -f /DATA/AppData/yunderagithubcompiler/.test_write
            echo "‚úÖ yunderagithubcompiler directory is writable by ubuntu user"
        else
            echo "‚ùå yunderagithubcompiler directory is NOT writable by ubuntu user"
        fi
        
        # Step 2: Create uidata directory with proper ownership from the start
        echo ""
        echo "üî® STEP 2: Creating uidata directory with careful permissions..."
        
        # Create uidata and immediately set proper ownership
        if mkdir -p /DATA/AppData/yunderagithubcompiler/uidata/ 2>/dev/null; then
            echo "   uidata directory created successfully"
        else
            echo "   uidata directory already exists"
        fi
        
        # Set ownership immediately after creation
        if chown ubuntu:988 /DATA/AppData/yunderagithubcompiler/uidata/ 2>/dev/null; then
            echo "‚úÖ Set uidata ownership to ubuntu:988"
        else
            echo "‚ùå Cannot set uidata ownership to ubuntu:988"
        fi
        
        # Set permissions
        if chmod 755 /DATA/AppData/yunderagithubcompiler/uidata/ 2>/dev/null; then
            echo "‚úÖ Set uidata permissions to 755"
        else
            echo "‚ùå Cannot set uidata permissions to 755"
        fi
        
        echo "   Final state: $(ls -ld /DATA/AppData/yunderagithubcompiler/uidata/ 2>/dev/null || echo 'FAILED')"
        
        # Test write access to uidata
        if touch /DATA/AppData/yunderagithubcompiler/uidata/.test_write 2>/dev/null; then
            rm -f /DATA/AppData/yunderagithubcompiler/uidata/.test_write
            echo "‚úÖ uidata directory is writable by ubuntu user"
        else
            echo "‚ùå uidata directory is NOT writable by ubuntu user"
        fi
        
        # Step 3: Create .ssh directory with EXTRA CARE for permissions
        echo ""
        echo "üî® STEP 3: Creating .ssh directory with EXTRA CAREFUL permissions..."
        
        # This is the critical step - .ssh directory must be owned by ubuntu, not root
        if mkdir -p /DATA/AppData/yunderagithubcompiler/uidata/.ssh/ 2>/dev/null; then
            echo "   .ssh directory created successfully"
        else
            echo "   .ssh directory already exists"
        fi
        
        # IMMEDIATELY set ownership to prevent any root ownership issues
        echo "   Setting ownership IMMEDIATELY after creation..."
        if chown ubuntu:988 /DATA/AppData/yunderagithubcompiler/uidata/.ssh/ 2>/dev/null; then
            echo "‚úÖ Set .ssh ownership to ubuntu:988 IMMEDIATELY"
        else
            echo "‚ùå Cannot set .ssh ownership to ubuntu:988 - this is the problem!"
            echo "   Current ownership: $(ls -ld /DATA/AppData/yunderagithubcompiler/uidata/.ssh/ 2>/dev/null | awk '{print $3":"$4}' || echo 'unknown')"
        fi
        
        # Set proper permissions for .ssh directory (755 for directory access)
        if chmod 755 /DATA/AppData/yunderagithubcompiler/uidata/.ssh/ 2>/dev/null; then
            echo "‚úÖ Set .ssh permissions to 755"
        else
            echo "‚ùå Cannot set .ssh permissions to 755"
        fi
        
        echo "   Final state: $(ls -ld /DATA/AppData/yunderagithubcompiler/uidata/.ssh/ 2>/dev/null || echo 'FAILED')"
        
        # Test write access to .ssh
        if touch /DATA/AppData/yunderagithubcompiler/uidata/.ssh/.test_write 2>/dev/null; then
            rm -f /DATA/AppData/yunderagithubcompiler/uidata/.ssh/.test_write
            echo "‚úÖ .ssh directory is writable - SSH key generation should work!"
        else
            echo "‚ùå .ssh directory is NOT writable"
            echo "   This is exactly why SSH key generation fails"
            echo "   Current permissions: $(ls -ld /DATA/AppData/yunderagithubcompiler/uidata/.ssh/ 2>/dev/null || echo 'cannot read')"
        fi
        
        # Also create ubuntu SSH directory for fallback
        mkdir -p /home/ubuntu/.ssh
        chmod 700 /home/ubuntu/.ssh 2>/dev/null && echo "‚úÖ Ubuntu SSH directory ready as fallback" || echo "‚ö†Ô∏è Could not set ubuntu SSH permissions"
        
        echo ""
        echo "üìã SUMMARY: Directory permission fixing completed"
        echo "   Base dir: $(ls -ld /DATA/AppData/yunderagithubcompiler/ 2>/dev/null | awk '{print $1, $3, $4}' || echo 'FAILED')"
        echo "   uidata:   $(ls -ld /DATA/AppData/yunderagithubcompiler/uidata/ 2>/dev/null | awk '{print $1, $3, $4}' || echo 'FAILED')"
        echo "   .ssh:     $(ls -ld /DATA/AppData/yunderagithubcompiler/uidata/.ssh/ 2>/dev/null | awk '{print $1, $3, $4}' || echo 'FAILED')"
    ) > "$SSH_SETUP_LOG" 2>&1
    
    # Continue SSH setup in the same log file
    (
        echo ""
        echo "üîê Checking for existing SSH keys..."
        FINAL_KEY_DIR="/DATA/AppData/yunderagithubcompiler/uidata/.ssh"
        
        if [ ! -f "$FINAL_KEY_DIR/id_ed25519" ]; then
            echo "üîê Generating SSH key pair directly in uidata directory..."
            echo "   Permissions should now be fixed to allow this"
            
            # Check if ssh-keygen exists
            if ! command -v ssh-keygen >/dev/null 2>&1; then
                echo "‚ùå ssh-keygen not found - SSH setup will be skipped"
                echo "Available commands in PATH:"
                echo "$PATH" | tr ':' '\n' | while read dir; do ls "$dir"/ssh* 2>/dev/null | head -5; done
                echo "‚ö†Ô∏è SSH functionality will not be available, but installation will continue"
                echo "üîö Skipping remaining SSH setup steps"
            else
            
            # Generate SSH key directly in the target directory
            if ssh-keygen -t ed25519 -f "$FINAL_KEY_DIR/id_ed25519" -N "" -C "yundera-compiler@container"; then
                echo "‚úÖ SSH key generation successful in target directory"
                
                # Set proper permissions on the generated keys (chmod only)
                chmod 600 "$FINAL_KEY_DIR/id_ed25519" && echo "‚úÖ Set private key permissions (600)" || echo "‚ö†Ô∏è Could not set private key permissions"
                chmod 644 "$FINAL_KEY_DIR/id_ed25519.pub" && echo "‚úÖ Set public key permissions (644)" || echo "‚ö†Ô∏è Could not set public key permissions"
                
                # Verify the files were created correctly
                echo "üìã SSH key files created:"
                ls -la "$FINAL_KEY_DIR/" || echo "Cannot list SSH directory"
            else
                echo "‚ùå SSH key generation failed in target directory!"
                echo "   Falling back to home directory generation..."
                
                # Fallback: generate in home directory (remove existing keys first to avoid prompt)
                echo "üßπ Removing any existing SSH keys in home directory..."
                rm -f /home/ubuntu/.ssh/id_ed25519 /home/ubuntu/.ssh/id_ed25519.pub
                
                if ssh-keygen -t ed25519 -f "/home/ubuntu/.ssh/id_ed25519" -N "" -C "yundera-compiler@container"; then
                    echo "‚úÖ SSH key generation successful in home directory fallback"
                    chmod 600 /home/ubuntu/.ssh/id_ed25519 && echo "‚úÖ Set private key permissions in home"
                    chmod 644 /home/ubuntu/.ssh/id_ed25519.pub && echo "‚úÖ Set public key permissions in home"
                    echo "‚ö†Ô∏è Keys are in /home/ubuntu/.ssh/ instead of preferred location"
                else
                    echo "‚ùå SSH key generation failed even in home directory!"
                    echo "‚ö†Ô∏è SSH functionality will not be available, but installation will continue"
                fi
            fi
            fi  # Close the ssh-keygen check
        else
            echo "‚úÖ SSH key pair already exists in target directory"
        fi
        
        echo ""
        echo "üîë Setting up authorized_keys..."
        # Find the public key (try both locations)
        PUBLIC_KEY_FILE=""
        TEMP_KEY_DIR="/home/ubuntu/.ssh"  # Define this variable here since we removed it above
        
        if [ -f "$FINAL_KEY_DIR/id_ed25519.pub" ]; then
            PUBLIC_KEY_FILE="$FINAL_KEY_DIR/id_ed25519.pub"
            echo "üìç Using public key from: $PUBLIC_KEY_FILE"
        elif [ -f "$TEMP_KEY_DIR/id_ed25519.pub" ]; then
            PUBLIC_KEY_FILE="$TEMP_KEY_DIR/id_ed25519.pub"
            echo "üìç Using public key from: $PUBLIC_KEY_FILE"
        else
            echo "‚ùå SSH public key not found in either location!"
            echo "   Checked: $FINAL_KEY_DIR/id_ed25519.pub"
            echo "   Checked: $TEMP_KEY_DIR/id_ed25519.pub"
            echo "   Directory listings:"
            echo "   Final dir: $(ls -la "$FINAL_KEY_DIR/" 2>/dev/null || echo 'does not exist')"
            echo "   Temp dir: $(ls -la "$TEMP_KEY_DIR/" 2>/dev/null || echo 'does not exist')"
            echo "‚ö†Ô∏è SSH functionality will not be available, but installation will continue"
            PUBLIC_KEY_FILE=""  # Set empty to skip authorized_keys setup
        fi
        
        # Only proceed with authorized_keys setup if we have a public key file
        if [ -n "$PUBLIC_KEY_FILE" ] && [ -f "$PUBLIC_KEY_FILE" ]; then
            PUBLIC_KEY=$(cat "$PUBLIC_KEY_FILE")
            echo "üîë Public key content: $PUBLIC_KEY"
            echo "   Key length: ${#PUBLIC_KEY} characters"
            
            # Ensure authorized_keys exists and add key if not already present
            if ! touch /home/ubuntu/.ssh/authorized_keys 2>/dev/null; then
                echo "‚ùå Failed to create authorized_keys - SSH setup incomplete but installation will continue"
            else
                if ! grep -Fq "$PUBLIC_KEY" /home/ubuntu/.ssh/authorized_keys 2>/dev/null; then
                    if ! echo "$PUBLIC_KEY" >> /home/ubuntu/.ssh/authorized_keys 2>/dev/null; then
                        echo "‚ùå Failed to add key to authorized_keys - SSH setup incomplete but installation will continue"
                    else
                        echo "‚úÖ SSH public key added to ubuntu@host authorized_keys"
                    fi
                else
                    echo "‚úÖ SSH public key already in ubuntu@host authorized_keys"
                fi
                
                # Set proper permissions for SSH files
                chmod 600 /home/ubuntu/.ssh/authorized_keys || echo "‚ùå Failed to chmod authorized_keys"
                
                # Verify the key was added
                if grep -Fq "$PUBLIC_KEY" /home/ubuntu/.ssh/authorized_keys; then
                    echo "‚úÖ Verification: Key found in authorized_keys"
                    echo "   authorized_keys file size: $(wc -l /home/ubuntu/.ssh/authorized_keys | awk '{print $1}') lines"
                else
                    echo "‚ùå Verification failed: Key not found in authorized_keys"
                    echo "‚ö†Ô∏è SSH setup incomplete but installation will continue"
                fi
            fi
        else
            echo "‚ö†Ô∏è No valid SSH public key available - skipping authorized_keys setup"
        fi
        
        echo "üîë SSH setup completed - apps can now SSH to ubuntu@host"
        
        echo ""
        echo "=== SSH Setup Completed Successfully at $(date) ==="
    ) >> "$SSH_SETUP_LOG" 2>&1
    
    echo "‚úÖ SSH setup completed with user-manageable file permissions (check $SSH_SETUP_LOG for details)"
    
    # Create a simplified watcher that waits for compose file and fixes docker.sock
    # We use `EOF` without quotes to allow the parent shell to expand ${AUTH_HASH} into the script's text.
    # All other dollar signs are escaped (\$) to be treated as literal characters by the background script.
    cat > /tmp/yundera-docker-sock-fixer.sh << EOF
    #!/bin/bash
    echo "üîÑ Yundera docker.sock fixer started at \$(date)"
    
    COMPOSE_FILE="/DATA/AppData/casaos/apps/yunderagithubcompiler/docker-compose.yml"
    CONTAINER_NAME="yunderagithubcompiler"
    
    echo "üìÅ Target compose file: \$COMPOSE_FILE"
    echo "üê≥ Target container: \$CONTAINER_NAME"
    
    # Get Docker group ID from host system
    echo "üîç Detecting Docker group ID..."
    if [ -S /var/run/docker.sock ]; then
      DOCKER_GID=\$(stat -c '%g' /var/run/docker.sock)
      echo "‚úÖ Docker group ID detected: \$DOCKER_GID"
    else
      echo "‚ùå Docker socket not found on host, using fallback GID"
      DOCKER_GID=999
    fi
    
    # Step 1: Wait for compose file to exist
    echo "üîç Step 1: Waiting for compose file to exist..."
    counter=0
    max_wait=120  # 120 seconds max wait (2 minutes)
    
    while [ \$counter -lt \$max_wait ]; do
      if [ -f "\$COMPOSE_FILE" ]; then
        echo "‚úÖ Compose file exists after \$counter seconds"
        break
      fi
      echo "‚è≥ Compose file not found yet... (\${counter}s/\${max_wait}s)"
      sleep 2
      counter=\$((counter + 2))
    done
    
    if [ ! -f "\$COMPOSE_FILE" ]; then
      echo "‚ùå Compose file not found after \${max_wait}s, exiting"
      exit 1
    fi
    
    # Step 2: Check if docker.sock is already mounted
    SERVICE_SECTION=\$(awk '/^[[:space:]]*yunderagithubcompiler:/,/^[[:space:]]*x-casaos:/ {
      if (/^[[:space:]]*x-casaos:/) exit;
      print
    }' "\$COMPOSE_FILE")
    
    if echo "\$SERVICE_SECTION" | grep -q "/var/run/docker.sock:/var/run/docker.sock"; then
      echo "‚úÖ Docker.sock is already mounted in service volumes section"
    else
      echo "‚ùå Docker.sock is NOT mounted in service volumes section"
      
      # Step 3: Add docker.sock mount and environment variables
      echo "üîß Step 3: Adding docker.sock mount to compose file..."
      
      cp "\$COMPOSE_FILE" "\$COMPOSE_FILE.backup"
      echo "üìã Backed up compose file to \$COMPOSE_FILE.backup"
      
      if echo "\$SERVICE_SECTION" | grep -q "volumes:"; then
        echo "üìÅ Found existing volumes section in service"
        
        sed -i '/^[[:space:]]*volumes:/,/^[[:space:]]*networks:/ {
          /^[[:space:]]*read_only:[[:space:]]*true/ {
            a\            - type: bind\n              source: /var/run/docker.sock\n              target: /var/run/docker.sock
          }
        }' "\$COMPOSE_FILE"
        
        echo "üîß Adding Docker group ID and AUTH_HASH to environment variables..."
        
        sed -i "s/WEBUI_PORT: \".*\"/&\\n            DOCKER_GID: \"\$DOCKER_GID\"\\n            AUTH_HASH: \"${AUTH_HASH}\"/" "\$COMPOSE_FILE"
        
        echo "‚úÖ Added docker.sock mount and environment variables to existing sections."
      else
        echo "üìÅ No volumes section found in service, adding one"
        
        sed -i '/^[[:space:]]*yunderagithubcompiler:/,/^[[:space:]]*networks:/ {
          /^[[:space:]]*networks:/ i\    volumes:\n        - type: bind\n          source: /var/run/docker.sock\n          target: /var/run/docker.sock\n
        }' "\$COMPOSE_FILE"
        echo "‚úÖ Added volumes section with docker.sock mount"
      fi

      # Modify the index line to include the hash
      sed -i "s|index: /|index: /?hash=${AUTH_HASH}|" "\$COMPOSE_FILE"

      # Cleanly remove the entire pre-install-cmd line from the final compose file
      echo "üîß Removing pre-install-cmd from final compose file..."
      sed -i '/^[[:space:]]*pre-install-cmd:/d' "\$COMPOSE_FILE"
    fi
    
    # Step 4: Wait for container to be created
    echo "üîç Step 4: Waiting for container to be created..."
    counter=0
    max_wait=60  # 60 seconds max wait
    
    while [ \$counter -lt \$max_wait ]; do
      if docker ps -a --filter "name=\$CONTAINER_NAME" --format "{{.Names}}" | grep -q "^\$CONTAINER_NAME\$"; then
        echo "‚úÖ Container \$CONTAINER_NAME found after \$counter seconds"
        break
      fi
      echo "‚è≥ Container not found yet... (\${counter}s/\${max_wait}s)"
      sleep 2
      counter=\$((counter + 2))
    done
    
    if ! docker ps -a --filter "name=\$CONTAINER_NAME" --format "{{.Names}}" | grep -q "^\$CONTAINER_NAME\$"; then
      echo "‚ùå Container \$CONTAINER_NAME not found after \${max_wait}s"
      echo "üìã Available containers:"
      docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"
      exit 1
    fi
    
    # --- MINIMAL FIX: use the SAME compose project as CasaOS to avoid name conflict ---
    PROJECT=\$(docker inspect -f '{{ index .Config.Labels "com.docker.compose.project" }}' "\$CONTAINER_NAME" 2>/dev/null || true)  # <<< MINIMAL FIX
    [ -z "\$PROJECT" ] && PROJECT=\$(basename "/DATA/AppData/casaos/apps/yunderagithubcompiler")                                  # <<< MINIMAL FIX
    echo "üîß Using compose project: \$PROJECT"                                                                                    # <<< MINIMAL FIX
    # -----------------------------------------------------------------------------------
    
    # Step 5: Restart the container with new compose file
    echo "üîÑ Step 5: Restarting container with updated compose file..."
    
    cd "/DATA/AppData/casaos/apps/yunderagithubcompiler"
    if docker compose version >/dev/null 2>&1; then
      docker compose -p "\$PROJECT" up -d --force-recreate     # <<< MINIMAL FIX
    elif command -v docker-compose >/dev/null 2>&1; then
      docker-compose -p "\$PROJECT" up -d --force-recreate     # <<< MINIMAL FIX
    else
      echo "‚ö†Ô∏è No docker compose binary found; skipping restart"
      exit 0
    fi
    
    # Step 6: Verify the restart
    echo "‚úÖ Step 6: Verifying restart..."
    sleep 5
    
    NEW_STATUS=\$(docker ps --filter "name=\$CONTAINER_NAME" --format "{{.Status}}")
    if [ -n "\$NEW_STATUS" ]; then
      echo "‚úÖ Container \$CONTAINER_NAME is now running: \$NEW_STATUS"
      
      if docker exec "\$CONTAINER_NAME" test -S /var/run/docker.sock 2>/dev/null; then
        echo "‚úÖ Docker.sock is successfully mounted and accessible in container"
      else
        echo "‚ùå Docker.sock is NOT accessible in container"
      fi
    else
      echo "‚ùå Container \$CONTAINER_NAME is not running after restart"
    fi
    
    echo "üèÅ Watcher script completed at \$(date)"
    EOF
    
    # Make it executable and run in background
    chmod +x /tmp/yundera-docker-sock-fixer.sh
    nohup /tmp/yundera-docker-sock-fixer.sh > /tmp/yundera-docker-sock-fixer.log 2>&1 &
    
    echo "üöÄ Docker.sock fixer launched, check logs at /tmp/yundera-docker-sock-fixer.log"
