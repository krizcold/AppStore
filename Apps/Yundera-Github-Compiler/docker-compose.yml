name: yunderagithubcompiler

services:
  yunderagithubcompiler:
    image: krizcold/yundera-github-compiler:latest
    container_name: yunderagithubcompiler
    restart: unless-stopped
    expose:
      - "3000"
    user: "root"
    entrypoint: ["/bin/sh"]
    command:
      - -c
      - |
        npm run setup
    environment:
      # Application settings
      WEBUI_PORT: "3000"
      
      # CasaOS integration
      DEPLOYMENT_MODE: "appstore"
      CASAOS_API_HOST: "localhost"
      CASAOS_API_PORT: "8080"
      DATA_ROOT: $DATA_ROOT
      
      # Yundera platform integration
      DOMAIN: $DOMAIN
      PROVIDER_STR: $PROVIDER_STR
      UID: $UID
      DEFAULT_PWD: $DEFAULT_PWD
      PUBLIC_IP: $PUBLIC_IP
      DEFAULT_USER: $DEFAULT_USER
      
      # Authentication and paths
      JWT_SECRET: $JWT_SECRET
      AUTHORITY_ENDPOINT: $AUTHORITY_ENDPOINT
      COMPOSE_FOLDER_PATH: $COMPOSE_FOLDER_PATH
      BASE_PATH: $BASE_PATH
      MOCK: $MOCK
      
      # Pass through the host's CasaOS environment variables.
      # These will be populated by the AppStore during installation.
      PUID: $PUID
      PGID: $PGID
      REF_DOMAIN: $REF_DOMAIN
      REF_NET: $REF_NET
      REF_PORT: $REF_PORT
      REF_SCHEME: $REF_SCHEME
      REF_SEPARATOR: $REF_SEPARATOR
      
      # Debug/logging settings
      LOG_APPS_BEACON: $LOG_APPS_BEACON
      
      user: $user
      default_pwd: $default_pwd
      public_ip: $public_ip

    volumes:        
      # cloned repos
      - type: bind
        source: /DATA/AppData/yunderagithubcompiler/repos
        target: /app/repos

      # persistent UI data storage
      - type: bind
        source: /DATA/AppData/yunderagithubcompiler/uidata
        target: /app/uidata

      # Writable mount for app metadata
      - type: bind
        source: /DATA/AppData
        target: /DATA/AppData

      # Bind mount for the main app directory
      - type: bind
        source: /DATA/AppData/casaos/apps/yunderagithubcompiler
        target: /DATA/AppData/casaos/apps/yunderagithubcompiler
        read_only: true

      - type: bind
        source: /var/run/docker.sock
        target: /var/run/docker.sock

    # Connect to the same network as the CasaOS service
    networks:
      - pcs
    
    # Add privileges to access CasaOS data (similar to CasaOS container)
    privileged: true
    
    # Add capabilities
    cap_add:
      - SYS_ADMIN
      - NET_ADMIN

    x-casaos:
      volumes:
        - container: /app/repos
          description:
            en_us: "Git repos are cloned here."
        - container: /app/uidata
          description:
            en_us: "Persistent UI data storage."

# Define the network as external, since it's created by the main NSL stack
networks:
  pcs:
    external: true

x-casaos:
  architectures:
    - amd64
    - arm64
  main: yunderagithubcompiler
  author: krizcold
  developer: krizcold
  icon: https://github.com/krizcold/Yundera-Github-Compiler/blob/main/YunderaCompiler.png?raw=true
  tagline:
    en_us: "Automatically build and deploy GitHub repos on Yundera"
  category: Utilities
  description:
    en_us: "Clone, build, and run Docker-based projects directly from GitHub URLs."
  title:
    en_us: "Yundera GitHub Compiler"
  store_app_id: yunderagithubcompiler
  is_uncontrolled: false
  index: /
  webui_port: 3000
  pre-install-cmd: |
    # Generate the hash value that will be embedded into the background script.
    if command -v openssl >/dev/null 2>&1; then
      AUTH_HASH=$(openssl rand -hex 64)
    else
      # minimal fallback if openssl isn't present
      AUTH_HASH=$(dd if=/dev/urandom bs=32 count=1 2>/dev/null | od -An -tx1 | tr -d ' \n')
    fi
    
    echo "ðŸš€ Yundera GitHub Compiler pre-install starting..."
    
    # Setup SSH access for pre-install commands with PROPER USER PERMISSIONS
    # Log everything to help debug failures
    SSH_SETUP_LOG="/tmp/yundera-ssh-setup-$(date +%Y%m%d-%H%M%S).log"
    echo "ðŸ”§ Setting up SSH access with user-manageable permissions (logging to $SSH_SETUP_LOG)..."
    
    (
        set +e  # <<< minimal: don't let best-effort steps abort the whole pre-install
        echo "=== SSH Setup Started at $(date) ==="
        echo "Host: $(hostname)"
        echo "User: $(whoami)"
        echo "UID/GID: $(id)"
        echo "Working directory: $(pwd)"
        echo ""
        
        echo "ðŸ“ Fresh PCS installation - creating directory structure with proper permissions..."
        
        # Check if this is truly a fresh installation
        if [ -d "/DATA/AppData/yunderagithubcompiler" ]; then
            echo "âš ï¸ WARNING: yunderagithubcompiler directory already exists - checking ownership..."
            echo "   Existing: $(ls -ld /DATA/AppData/yunderagithubcompiler/ 2>/dev/null || echo 'cannot read')"
        fi
        
        # Step 1: Create yunderagithubcompiler directory with proper ownership from the start
        echo ""
        echo "ðŸ”¨ STEP 1: Creating yunderagithubcompiler directory with careful permissions..."
        
        if mkdir -p /DATA/AppData/yunderagithubcompiler/ 2>/dev/null; then
            echo "   Directory created successfully"
        else
            echo "   Directory already exists"
        fi
        
        # Ensure proper ownership (ubuntu user with docker group)
        chown ubuntu:988 /DATA/AppData/yunderagithubcompiler/ 2>/dev/null && echo "âœ… Set yunderagithubcompiler ownership to ubuntu:988" || echo "âŒ Cannot set yunderagithubcompiler ownership to ubuntu:988"
        chmod 755 /DATA/AppData/yunderagithubcompiler/ 2>/dev/null && echo "âœ… Set yunderagithubcompiler permissions to 755" || echo "âŒ Cannot set yunderagithubcompiler permissions to 755"
        echo "   Final state: $(ls -ld /DATA/AppData/yunderagithubcompiler/ 2>/dev/null || echo 'FAILED')"
        
        # Test write access
        if touch /DATA/AppData/yunderagithubcompiler/.test_write 2>/dev/null; then
            rm -f /DATA/AppData/yunderagithubcompiler/.test_write
            echo "âœ… yunderagithubcompiler directory is writable by ubuntu user"
        else
            echo "âŒ yunderagithubcompiler directory is NOT writable by ubuntu user"
        fi
        
        # Step 2: Create uidata directory with proper ownership from the start
        echo ""
        echo "ðŸ”¨ STEP 2: Creating uidata directory with careful permissions..."
        
        if mkdir -p /DATA/AppData/yunderagithubcompiler/uidata/ 2>/dev/null; then
            echo "   uidata directory created successfully"
        else
            echo "   uidata directory already exists"
        fi
        
        chown ubuntu:988 /DATA/AppData/yunderagithubcompiler/uidata/ 2>/dev/null && echo "âœ… Set uidata ownership to ubuntu:988" || echo "âŒ Cannot set uidata ownership to ubuntu:988"
        chmod 755 /DATA/AppData/yunderagithubcompiler/uidata/ 2>/dev/null && echo "âœ… Set uidata permissions to 755" || echo "âŒ Cannot set uidata permissions to 755"
        echo "   Final state: $(ls -ld /DATA/AppData/yunderagithubcompiler/uidata/ 2>/dev/null || echo 'FAILED')"
        
        # Test write access to uidata
        if touch /DATA/AppData/yunderagithubcompiler/uidata/.test_write 2>/dev/null; then
            rm -f /DATA/AppData/yunderagithubcompiler/uidata/.test_write
            echo "âœ… uidata directory is writable by ubuntu user"
        else
            echo "âŒ uidata directory is NOT writable by ubuntu user"
        fi
        
        # Step 3: Create .ssh directory with EXTRA CARE for permissions
        echo ""
        echo "ðŸ”¨ STEP 3: Creating .ssh directory with EXTRA CAREFUL permissions..."
        
        if mkdir -p /DATA/AppData/yunderagithubcompiler/uidata/.ssh/ 2>/dev/null; then
            echo "   .ssh directory created successfully"
        else
            echo "   .ssh directory already exists"
        fi
        
        echo "   Setting ownership IMMEDIATELY after creation..."
        chown ubuntu:988 /DATA/AppData/yunderagithubcompiler/uidata/.ssh/ 2>/dev/null && echo "âœ… Set .ssh ownership to ubuntu:988 IMMEDIATELY" || echo "âŒ Cannot set .ssh ownership to ubuntu:988 - this is the problem!"
        
        # (keeping your original 755 here to stay minimal, though 700 is typical)
        chmod 755 /DATA/AppData/yunderagithubcompiler/uidata/.ssh/ 2>/dev/null && echo "âœ… Set .ssh permissions to 755" || echo "âŒ Cannot set .ssh permissions to 755"
        echo "   Final state: $(ls -ld /DATA/AppData/yunderagithubcompiler/uidata/.ssh/ 2>/dev/null || echo 'FAILED')"
        
        # Test write access to .ssh
        if touch /DATA/AppData/yunderagithubcompiler/uidata/.ssh/.test_write 2>/dev/null; then
            rm -f /DATA/AppData/yunderagithubcompiler/uidata/.ssh/.test_write
            echo "âœ… .ssh directory is writable - SSH key generation should work!"
        else
            echo "âŒ .ssh directory is NOT writable"
        fi
        
        # Also create ubuntu SSH directory for fallback
        mkdir -p /home/ubuntu/.ssh
        chmod 700 /home/ubuntu/.ssh 2>/dev/null && echo "âœ… Ubuntu SSH directory ready as fallback" || echo "âš ï¸ Could not set ubuntu SSH permissions"
        
        echo ""
        echo "ðŸ“‹ SUMMARY: Directory permission fixing completed"
        echo "   Base dir: $(ls -ld /DATA/AppData/yunderagithubcompiler/ 2>/dev/null | awk '{print $1, $3, $4}' || echo 'FAILED')"
        echo "   uidata:   $(ls -ld /DATA/AppData/yunderagithubcompiler/uidata/ 2>/dev/null | awk '{print $1, $3, $4}' || echo 'FAILED')"
        echo "   .ssh:     $(ls -ld /DATA/AppData/yunderagithubcompiler/uidata/.ssh/ 2>/dev/null | awk '{print $1, $3, $4}' || echo 'FAILED')"
    ) > "$SSH_SETUP_LOG" 2>&1
    
    # Continue SSH setup in the same log file
    (
        set +e  # <<< minimal: best-effort; weâ€™ll validate writability after this
        echo ""
        echo "ðŸ” Checking for existing SSH keys..."
        FINAL_KEY_DIR="/DATA/AppData/yunderagithubcompiler/uidata/.ssh"
        
        if [ ! -f "$FINAL_KEY_DIR/id_ed25519" ]; then
            echo "ðŸ” Generating SSH key pair directly in uidata directory..."
            echo "   Permissions should now be fixed to allow this"
            
            if ! command -v ssh-keygen >/dev/null 2>&1; then
                echo "âŒ ssh-keygen not found - SSH setup will be skipped"
                echo "Available commands in PATH:"
                echo "$PATH" | tr ':' '\n' | while read dir; do ls "$dir"/ssh* 2>/dev/null | head -5; done
                echo "âš ï¸ SSH functionality will not be available, but installation will continue"
                echo "ðŸ”š Skipping remaining SSH setup steps"
            else
              if ssh-keygen -t ed25519 -f "$FINAL_KEY_DIR/id_ed25519" -N "" -C "yundera-compiler@container"; then
                  echo "âœ… SSH key generation successful in target directory"
                  chmod 600 "$FINAL_KEY_DIR/id_ed25519" 2>/dev/null || true
                  chmod 644 "$FINAL_KEY_DIR/id_ed25519.pub" 2>/dev/null || true
                  ls -la "$FINAL_KEY_DIR/" || echo "Cannot list SSH directory"
              else
                  echo "âŒ SSH key generation failed in target directory!"
                  echo "   Falling back to home directory generation..."
                  rm -f /home/ubuntu/.ssh/id_ed25519 /home/ubuntu/.ssh/id_ed25519.pub
                  if ssh-keygen -t ed25519 -f "/home/ubuntu/.ssh/id_ed25519" -N "" -C "yundera-compiler@container"; then
                      echo "âœ… SSH key generation successful in home directory fallback"
                      chmod 600 /home/ubuntu/.ssh/id_ed25519 2>/dev/null || true
                      chmod 644 /home/ubuntu/.ssh/id_ed25519.pub 2>/dev/null || true
                      echo "âš ï¸ Keys are in /home/ubuntu/.ssh/ instead of preferred location"
                  else
                      echo "âŒ SSH key generation failed even in home directory!"
                      echo "âš ï¸ SSH functionality will not be available, but installation will continue"
                  fi
              fi
            fi
        else
            echo "âœ… SSH key pair already exists in target directory"
        fi
        
        echo ""
        echo "ðŸ”‘ Setting up authorized_keys..."
        PUBLIC_KEY_FILE=""
        TEMP_KEY_DIR="/home/ubuntu/.ssh"
        
        if [ -f "$FINAL_KEY_DIR/id_ed25519.pub" ]; then
            PUBLIC_KEY_FILE="$FINAL_KEY_DIR/id_ed25519.pub"
            echo "ðŸ“ Using public key from: $PUBLIC_KEY_FILE"
        elif [ -f "$TEMP_KEY_DIR/id_ed25519.pub" ]; then
            PUBLIC_KEY_FILE="$TEMP_KEY_DIR/id_ed25519.pub"
            echo "ðŸ“ Using public key from: $PUBLIC_KEY_FILE"
        else
            echo "âŒ SSH public key not found in either location!"
            echo "âš ï¸ SSH functionality will not be available, but installation will continue"
            PUBLIC_KEY_FILE=""
        fi
        
        if [ -n "$PUBLIC_KEY_FILE" ] && [ -f "$PUBLIC_KEY_FILE" ]; then
            PUBLIC_KEY=$(cat "$PUBLIC_KEY_FILE")
            if ! touch /home/ubuntu/.ssh/authorized_keys 2>/dev/null; then
                echo "âŒ Failed to create authorized_keys - SSH setup incomplete but installation will continue"
            else
                if ! grep -Fq "$PUBLIC_KEY" /home/ubuntu/.ssh/authorized_keys 2>/dev/null; then
                    echo "$PUBLIC_KEY" >> /home/ubuntu/.ssh/authorized_keys 2>/dev/null || true
                    echo "âœ… SSH public key added to ubuntu@host authorized_keys"
                else
                    echo "âœ… SSH public key already in ubuntu@host authorized_keys"
                fi
                chmod 600 /home/ubuntu/.ssh/authorized_keys 2>/dev/null || true
            fi
        else
            echo "âš ï¸ No valid SSH public key available - skipping authorized_keys setup"
        fi
        
        echo "ðŸ”‘ SSH setup completed - apps can now SSH to ubuntu@host"
        echo ""
        echo "=== SSH Setup Completed Successfully at $(date) ==="
    ) >> "$SSH_SETUP_LOG" 2>&1
    
    echo "âœ… SSH setup completed with user-manageable file permissions (check $SSH_SETUP_LOG for details)"
    
    # --- single hard check so we still fail on *real* SSH pre-req problems ---
    if ! touch /DATA/AppData/yunderagithubcompiler/uidata/.ssh/.w && rm -f /DATA/AppData/yunderagithubcompiler/uidata/.ssh/.w; then
      echo "âŒ /DATA/AppData/yunderagithubcompiler/uidata/.ssh is not writable. Aborting install."
      exit 1
    fi
    touch /tmp/yundera-ssh-setup.done  # marker: SSH finished OK
    
    # Create the watcher (unchanged logic, only minimal project adoption + wait for SSH marker)
    cat > /tmp/yundera-docker-sock-fixer.sh << EOF
    #!/bin/bash
    echo "ðŸ”„ Yundera docker.sock fixer started at \$(date)"
    
    COMPOSE_FILE="/DATA/AppData/casaos/apps/yunderagithubcompiler/docker-compose.yml"
    CONTAINER_NAME="yunderagithubcompiler"
    
    echo "ðŸ“ Target compose file: \$COMPOSE_FILE"
    echo "ðŸ³ Target container: \$CONTAINER_NAME"

    # Wait for SSH setup to finish (marker)
    for i in \$(seq 1 30); do
      [ -f /tmp/yundera-ssh-setup.done ] && break
      sleep 1
    done
    
    # Get Docker group ID from host system
    echo "ðŸ” Detecting Docker group ID..."
    if [ -S /var/run/docker.sock ]; then
      DOCKER_GID=\$(stat -c '%g' /var/run/docker.sock)
      echo "âœ… Docker group ID detected: \$DOCKER_GID"
    else
      echo "âŒ Docker socket not found on host, using fallback GID"
      DOCKER_GID=999
    fi
    
    # Step 1: Wait for compose file to exist
    echo "ðŸ” Step 1: Waiting for compose file to exist..."
    counter=0
    max_wait=120
    
    while [ \$counter -lt \$max_wait ]; do
      if [ -f "\$COMPOSE_FILE" ]; then
        echo "âœ… Compose file exists after \$counter seconds"
        break
      fi
      echo "â³ Compose file not found yet... (\${counter}s/\${max_wait}s)"
      sleep 2
      counter=\$((counter + 2))
    done
    
    if [ ! -f "\$COMPOSE_FILE" ]; then
      echo "âŒ Compose file not found after \${max_wait}s, exiting"
      exit 1
    fi
    
    # Step 2: Check if docker.sock is already mounted
    SERVICE_SECTION=\$(awk '/^[[:space:]]*yunderagithubcompiler:/,/^[[:space:]]*x-casaos:/ {
      if (/^[[:space:]]*x-casaos:/) exit;
      print
    }' "\$COMPOSE_FILE")
    
    if echo "\$SERVICE_SECTION" | grep -q "/var/run/docker.sock:/var/run/docker.sock"; then
      echo "âœ… Docker.sock is already mounted in service volumes section"
    else
      echo "âŒ Docker.sock is NOT mounted in service volumes section"
      
      # Step 3: Add docker.sock mount and environment variables
      echo "ðŸ”§ Step 3: Adding docker.sock mount to compose file..."
      
      cp "\$COMPOSE_FILE" "\$COMPOSE_FILE.backup"
      echo "ðŸ“‹ Backed up compose file to \$COMPOSE_FILE.backup"
      
      if echo "\$SERVICE_SECTION" | grep -q "volumes:"; then
        echo "ðŸ“ Found existing volumes section in service"
        
        sed -i '/^[[:space:]]*volumes:/,/^[[:space:]]*networks:/ {
          /^[[:space:]]*read_only:[[:space:]]*true/ {
            a\            - type: bind\n              source: /var/run/docker.sock\n              target: /var/run/docker.sock
          }
        }' "\$COMPOSE_FILE"
        
        echo "ðŸ”§ Adding Docker group ID and AUTH_HASH to environment variables..."
        sed -i "s/WEBUI_PORT: \".*\"/&\\n            DOCKER_GID: \"\$DOCKER_GID\"\\n            AUTH_HASH: \"${AUTH_HASH}\"/" "\$COMPOSE_FILE"
      else
        echo "ðŸ“ No volumes section found in service, adding one"
        
        sed -i '/^[[:space:]]*yunderagithubcompiler:/,/^[[:space:]]*networks:/ {
          /^[[:space:]]*networks:/ i\    volumes:\n        - type: bind\n          source: /var/run/docker.sock\n          target: /var/run/docker.sock\n
        }' "\$COMPOSE_FILE"
      fi

      # Modify the index line to include the hash
      sed -i "s|index: /|index: /?hash=${AUTH_HASH}|" "\$COMPOSE_FILE"

      # Cleanly remove the entire pre-install-cmd line from the final compose file
      echo "ðŸ”§ Removing pre-install-cmd from final compose file..."
      sed -i '/^[[:space:]]*pre-install-cmd:/d' "\$COMPOSE_FILE"
    fi
    
    # Step 4: Wait for container to be created
    echo "ðŸ” Step 4: Waiting for container to be created..."
    counter=0
    max_wait=60
    
    while [ \$counter -lt \$max_wait ]; do
      if docker ps -a --filter "name=\$CONTAINER_NAME" --format "{{.Names}}" | grep -q "^\$CONTAINER_NAME\$"; then
        echo "âœ… Container \$CONTAINER_NAME found after \$counter seconds"
        break
      fi
      echo "â³ Container not found yet... (\${counter}s/\${max_wait}s)"
      sleep 2
      counter=\$((counter + 2))
    done
    
    if ! docker ps -a --filter "name=\$CONTAINER_NAME" --format "{{.Names}}" | grep -q "^\$CONTAINER_NAME\$"; then
      echo "âŒ Container \$CONTAINER_NAME not found after \${max_wait}s"
      echo "ðŸ“‹ Available containers:"
      docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"
      exit 1
    fi

    # Adopt CasaOS compose project to avoid name conflicts (minimal change)
    PROJECT=\$(docker inspect -f '{{ index .Config.Labels "com.docker.compose.project" }}' "\$CONTAINER_NAME" 2>/dev/null || true)
    [ -z "\$PROJECT" ] && PROJECT=\$(basename "/DATA/AppData/casaos/apps/yunderagithubcompiler")
    echo "ðŸ”§ Using compose project: \$PROJECT"
    
    # Step 5: Restart the container with new compose file
    echo "ðŸ”„ Step 5: Restarting container with updated compose file..."
    
    cd "/DATA/AppData/casaos/apps/yunderagithubcompiler"
    if docker compose version >/dev/null 2>&1; then
      docker compose -p "\$PROJECT" up -d --force-recreate
    elif command -v docker-compose >/dev/null 2>&1; then
      docker-compose -p "\$PROJECT" up -d --force-recreate
    else
      echo "âš ï¸ No docker compose binary found; skipping restart"
      exit 0
    fi
    
    # Step 6: Verify the restart
    echo "âœ… Step 6: Verifying restart..."
    sleep 5
    
    NEW_STATUS=\$(docker ps --filter "name=\$CONTAINER_NAME" --format "{{.Status}}")
    if [ -n "\$NEW_STATUS" ]; then
      echo "âœ… Container \$CONTAINER_NAME is now running: \$NEW_STATUS"
      
      if docker exec "\$CONTAINER_NAME" test -S /var/run/docker.sock 2>/dev/null; then
        echo "âœ… Docker.sock is successfully mounted and accessible in container"
      else
        echo "âŒ Docker.sock is NOT accessible in container"
      fi
    else
      echo "âŒ Container \$CONTAINER_NAME is not running after restart"
    fi
    
    echo "ðŸ Watcher script completed at \$(date)"
    EOF
    
    # Make it executable and run in background
    chmod +x /tmp/yundera-docker-sock-fixer.sh
    nohup /tmp/yundera-docker-sock-fixer.sh > /tmp/yundera-docker-sock-fixer.log 2>&1 &
    
    echo "ðŸš€ Docker.sock fixer launched, check logs at /tmp/yundera-docker-sock-fixer.log"
