name: yunderagithubcompiler

services:
  yunderagithubcompiler:
    image: krizcold/yundera-github-compiler:latest
    container_name: yunderagithubcompiler
    restart: unless-stopped
    expose:
      - "3000"
    user: "root"
    entrypoint: ["/bin/sh"]
    command:
      - -c
      - |
        npm run setup
    environment:
      # Application settings
      WEBUI_PORT: "3000"
      
      # CasaOS integration
      DEPLOYMENT_MODE: "appstore"
      CASAOS_API_HOST: "localhost"
      CASAOS_API_PORT: "8080"
      DATA_ROOT: $DATA_ROOT
      
      # Yundera platform integration
      DOMAIN: $DOMAIN
      PROVIDER_STR: $PROVIDER_STR
      UID: $UID
      DEFAULT_PWD: $DEFAULT_PWD
      PUBLIC_IP: $PUBLIC_IP
      DEFAULT_USER: $DEFAULT_USER
      
      # Authentication and paths
      JWT_SECRET: $JWT_SECRET
      AUTHORITY_ENDPOINT: $AUTHORITY_ENDPOINT
      COMPOSE_FOLDER_PATH: $COMPOSE_FOLDER_PATH
      BASE_PATH: $BASE_PATH
      MOCK: $MOCK
      
      # Pass through the host's CasaOS environment variables.
      # These will be populated by the AppStore during installation.
      PUID: $PUID
      PGID: $PGID
      REF_DOMAIN: $REF_DOMAIN
      REF_NET: $REF_NET
      REF_PORT: $REF_PORT
      REF_SCHEME: $REF_SCHEME
      REF_SEPARATOR: $REF_SEPARATOR
      
      # Debug/logging settings
      LOG_APPS_BEACON: $LOG_APPS_BEACON
      
      user: $user
      default_pwd: $default_pwd
      public_ip: $public_ip

    volumes:        
      # cloned repos
      - type: bind
        source: /DATA/AppData/yunderagithubcompiler/repos
        target: /app/repos

      # persistent UI data storage
      - type: bind
        source: /DATA/AppData/yunderagithubcompiler/uidata
        target: /app/uidata

      # Writable mount for app metadata
      - type: bind
        source: /DATA/AppData
        target: /DATA/AppData

      # Bind mount for the main app directory
      - type: bind
        source: /DATA/AppData/casaos/apps/yunderagithubcompiler
        target: /DATA/AppData/casaos/apps/yunderagithubcompiler
        read_only: true

      - type: bind
        source: /var/run/docker.sock
        target: /var/run/docker.sock

    # Connect to the same network as the CasaOS service
    networks:
      - pcs
    
    # Add privileges to access CasaOS data (similar to CasaOS container)
    privileged: true
    
    # Add capabilities
    cap_add:
      - SYS_ADMIN
      - NET_ADMIN

    x-casaos:
      volumes:
        - container: /app/repos
          description:
            en_us: "Git repos are cloned here."
        - container: /app/uidata
          description:
            en_us: "Persistent UI data storage."

# Define the network as external, since it's created by the main NSL stack
networks:
  pcs:
    external: true

x-casaos:
  architectures:
    - amd64
    - arm64
  main: yunderagithubcompiler
  author: krizcold
  developer: krizcold
  icon: https://github.com/krizcold/Yundera-Github-Compiler/blob/main/YunderaCompiler.png?raw=true
  tagline:
    en_us: "Automatically build and deploy GitHub repos on Yundera"
  category: Utilities
  description:
    en_us: "Clone, build, and run Docker-based projects directly from GitHub URLs."
  title:
    en_us: "Yundera GitHub Compiler"
  store_app_id: yunderagithubcompiler
  is_uncontrolled: false
  index: /
  webui_port: 3000
  pre-install-cmd: |
    # EXECUTION ENVIRONMENT DIAGNOSTIC MODE
    echo "ðŸ”¬ EXECUTION ENVIRONMENT DIAGNOSTIC - Understanding CasaOS Pre-Install Context"
    echo "============================================================================"
    
    # Generate the hash value for later use
    if command -v openssl >/dev/null 2>&1; then
      AUTH_HASH=$(openssl rand -hex 64)
    else
      AUTH_HASH=$(dd if=/dev/urandom bs=32 count=1 2>/dev/null | od -An -tx1 | tr -d ' \n')
    fi
    
    ENV_DIAG_LOG="/tmp/yundera-env-diagnostic-$(date +%Y%m%d-%H%M%S).log"
    echo "ðŸ“‹ Environment diagnostic results will be logged to: $ENV_DIAG_LOG"
    
    (
        set +e  # Don't let diagnostic failures abort the pre-install
        echo "=== EXECUTION ENVIRONMENT DIAGNOSTICS Started at $(date) ==="
        
        echo ""
        echo "ðŸ  BASIC ENVIRONMENT ANALYSIS:"
        echo "   Hostname: $(hostname)"
        echo "   User: $(whoami)"
        echo "   UID/GID: $(id)"
        echo "   Working directory: $(pwd)"
        echo "   Shell: $SHELL"
        echo "   PATH: $PATH"
        
        echo ""
        echo "ðŸ³ CONTAINER VS HOST DETECTION:"
        echo "   Are we in a container?"
        if [ -f /.dockerenv ]; then
            echo "   âœ… /.dockerenv exists - we are in a container"
        else
            echo "   âŒ /.dockerenv not found"
        fi
        
        echo "   Container ID detection:"
        if [ -f /proc/1/cgroup ]; then
            echo "   /proc/1/cgroup: $(head -1 /proc/1/cgroup)"
        fi
        
        echo "   Process 1 command:"
        echo "   $(ps -p 1 -o comm= 2>/dev/null || echo 'cannot read')"
        
        echo ""
        echo "ðŸ—‚ï¸ FILESYSTEM ANALYSIS:"
        echo "   Root filesystem:"
        df -h / | head -2
        
        echo "   /tmp filesystem access:"
        echo "   Writing test file to /tmp..."
        TEST_FILE="/tmp/yundera-host-test-$(date +%s).txt"
        echo "CasaOS Pre-install Test - $(date)" > "$TEST_FILE" 2>/dev/null
        if [ -f "$TEST_FILE" ]; then
            echo "   âœ… Can write to /tmp: $TEST_FILE"
            echo "   File contents: $(cat "$TEST_FILE")"
            echo "   File permissions: $(ls -la "$TEST_FILE")"
        else
            echo "   âŒ Cannot write to /tmp"
        fi
        
        echo "   /DATA filesystem access:"
        if [ -d "/DATA" ]; then
            echo "   âœ… /DATA directory exists"
            echo "   /DATA contents: $(ls -la /DATA/ | head -5)"
            if mkdir -p /DATA/AppData/test-yundera-$(date +%s) 2>/dev/null; then
                echo "   âœ… Can write to /DATA/AppData/"
            else
                echo "   âŒ Cannot write to /DATA/AppData/"
            fi
        else
            echo "   âŒ /DATA directory does not exist"
        fi
        
        echo ""
        echo "ðŸ‹ DOCKER ACCESS TEST:"
        echo "   Docker socket access:"
        if [ -S /var/run/docker.sock ]; then
            echo "   âœ… Docker socket exists at /var/run/docker.sock"
            echo "   Socket permissions: $(ls -la /var/run/docker.sock)"
            if command -v docker >/dev/null 2>&1; then
                echo "   âœ… Docker command available"
                echo "   Testing docker access..."
                if timeout 5 docker ps >/dev/null 2>&1; then
                    echo "   âœ… Docker command works - can list containers"
                    echo "   Container list:"
                    docker ps --format "table {{.Names}}\t{{.Status}}" | head -5
                else
                    echo "   âŒ Docker command fails (permission denied?)"
                fi
            else
                echo "   âŒ Docker command not available"
            fi
        else
            echo "   âŒ Docker socket not accessible"
        fi
        
        echo ""
        echo "ðŸŒ NETWORK NAMESPACE TEST:"
        echo "   Network interfaces:"
        ip addr show 2>/dev/null | grep -E "^[0-9]+:" | head -5 || echo "   ip command not available"
        
        echo "   Can we reach external internet?"
        if ping -c 1 -W 2 8.8.8.8 >/dev/null 2>&1; then
            echo "   âœ… Internet connectivity works"
        else
            echo "   âŒ No internet connectivity"
        fi
        
        echo "   Can we reach host gateway?"
        GATEWAY=$(ip route show default 2>/dev/null | awk '/default via/ {print $3}' | head -1)
        if [ -n "$GATEWAY" ]; then
            echo "   Default gateway: $GATEWAY"
            if ping -c 1 -W 2 "$GATEWAY" >/dev/null 2>&1; then
                echo "   âœ… Can ping gateway"
            else
                echo "   âŒ Cannot ping gateway"
            fi
        else
            echo "   âŒ No default gateway found"
        fi
        
        echo ""
        echo "ðŸ”§ PROCESS AND SYSTEM INFO:"
        echo "   Process list (first 5):"
        ps aux | head -5 2>/dev/null || echo "   ps command failed"
        
        echo "   System uptime:"
        uptime 2>/dev/null || echo "   uptime command not available"
        
        echo "   Available commands:"
        for cmd in bash sh nc curl wget systemctl service; do
            if command -v "$cmd" >/dev/null 2>&1; then
                echo "   âœ… $cmd available"
            else
                echo "   âŒ $cmd not available"
            fi
        done
        
        echo ""
        echo "ðŸ“‹ EXECUTION CONTEXT ANALYSIS:"
        echo "   Based on findings:"
        if [ -f /.dockerenv ]; then
            echo "   ðŸ³ We are running in a container"
            if [ -S /var/run/docker.sock ]; then
                echo "   ðŸ”§ Docker socket is available - can potentially control host containers"
            fi
            if [ -d "/DATA" ]; then
                echo "   ðŸ“ Host /DATA filesystem is mounted - can access host files"
            fi
            if timeout 5 docker ps >/dev/null 2>&1; then
                echo "   âš¡ Docker commands work - can execute on host via docker exec"
            fi
        else
            echo "   ðŸ  We might be running directly on host"
        fi
        
        echo ""
        echo "ðŸŽ¯ RECOMMENDED APPROACH FOR HOST ACCESS:"
        if timeout 5 docker ps >/dev/null 2>&1; then
            echo "   âœ… USE DOCKER EXEC: Execute commands on host via docker exec"
            echo "   ðŸ’¡ Find host container or create temporary container with host access"
        elif [ -d "/DATA" ]; then
            echo "   âœ… USE FILESYSTEM: Direct file operations on mounted /DATA"
            echo "   ðŸ’¡ Write files directly to host filesystem via mounted volumes"
        else
            echo "   âŒ LIMITED OPTIONS: May need alternative approach"
            echo "   ðŸ’¡ Check if we're already running on host or need different method"
        fi
        
        echo ""
        echo "=== EXECUTION ENVIRONMENT DIAGNOSTICS Completed at $(date) ==="
    ) > "$ENV_DIAG_LOG" 2>&1
    
    echo "âœ… Environment diagnostics completed - check $ENV_DIAG_LOG for detailed results"
    
    # For now, we'll proceed without SSH setup to test basic functionality
    # The diagnostic log will show us what works and what doesn't
    touch /tmp/yundera-ssh-setup.done  # marker: diagnostics finished
    
    # Create the watcher (unchanged logic, only minimal project adoption + wait for SSH marker)
    cat > /tmp/yundera-docker-sock-fixer.sh << EOF
    #!/bin/bash
    echo "ðŸ”„ Yundera docker.sock fixer started at \$(date)"
    
    COMPOSE_FILE="/DATA/AppData/casaos/apps/yunderagithubcompiler/docker-compose.yml"
    CONTAINER_NAME="yunderagithubcompiler"
    
    echo "ðŸ“ Target compose file: \$COMPOSE_FILE"
    echo "ðŸ³ Target container: \$CONTAINER_NAME"

    # Wait for SSH setup to finish (marker)
    for i in \$(seq 1 30); do
      [ -f /tmp/yundera-ssh-setup.done ] && break
      sleep 1
    done
    
    # Get Docker group ID from host system
    echo "ðŸ” Detecting Docker group ID..."
    if [ -S /var/run/docker.sock ]; then
      DOCKER_GID=\$(stat -c '%g' /var/run/docker.sock)
      echo "âœ… Docker group ID detected: \$DOCKER_GID"
    else
      echo "âŒ Docker socket not found on host, using fallback GID"
      DOCKER_GID=999
    fi
    
    # Step 1: Wait for compose file to exist
    echo "ðŸ” Step 1: Waiting for compose file to exist..."
    counter=0
    max_wait=120
    
    while [ \$counter -lt \$max_wait ]; do
      if [ -f "\$COMPOSE_FILE" ]; then
        echo "âœ… Compose file exists after \$counter seconds"
        break
      fi
      echo "â³ Compose file not found yet... (\${counter}s/\${max_wait}s)"
      sleep 2
      counter=\$((counter + 2))
    done
    
    if [ ! -f "\$COMPOSE_FILE" ]; then
      echo "âŒ Compose file not found after \${max_wait}s, exiting"
      exit 1
    fi
    
    # Step 2: Check if docker.sock is already mounted
    SERVICE_SECTION=\$(awk '/^[[:space:]]*yunderagithubcompiler:/,/^[[:space:]]*x-casaos:/ {
      if (/^[[:space:]]*x-casaos:/) exit;
      print
    }' "\$COMPOSE_FILE")
    
    if echo "\$SERVICE_SECTION" | grep -q "/var/run/docker.sock:/var/run/docker.sock"; then
      echo "âœ… Docker.sock is already mounted in service volumes section"
    else
      echo "âŒ Docker.sock is NOT mounted in service volumes section"
      
      # Step 3: Add docker.sock mount and environment variables
      echo "ðŸ”§ Step 3: Adding docker.sock mount to compose file..."
      
      cp "\$COMPOSE_FILE" "\$COMPOSE_FILE.backup"
      echo "ðŸ“‹ Backed up compose file to \$COMPOSE_FILE.backup"
      
      if echo "\$SERVICE_SECTION" | grep -q "volumes:"; then
        echo "ðŸ“ Found existing volumes section in service"
        
        sed -i '/^[[:space:]]*volumes:/,/^[[:space:]]*networks:/ {
          /^[[:space:]]*read_only:[[:space:]]*true/ {
            a\            - type: bind\n              source: /var/run/docker.sock\n              target: /var/run/docker.sock
          }
        }' "\$COMPOSE_FILE"
        
        echo "ðŸ”§ Adding Docker group ID and AUTH_HASH to environment variables..."
        sed -i "s/WEBUI_PORT: \".*\"/&\\n            DOCKER_GID: \"\$DOCKER_GID\"\\n            AUTH_HASH: \"${AUTH_HASH}\"/" "\$COMPOSE_FILE"
      else
        echo "ðŸ“ No volumes section found in service, adding one"
        
        sed -i '/^[[:space:]]*yunderagithubcompiler:/,/^[[:space:]]*networks:/ {
          /^[[:space:]]*networks:/ i\    volumes:\n        - type: bind\n          source: /var/run/docker.sock\n          target: /var/run/docker.sock\n
        }' "\$COMPOSE_FILE"
      fi

      # Modify the index line to include the hash
      sed -i "s|index: /|index: /?hash=${AUTH_HASH}|" "\$COMPOSE_FILE"

      # Cleanly remove the entire pre-install-cmd line from the final compose file
      echo "ðŸ”§ Removing pre-install-cmd from final compose file..."
      sed -i '/^[[:space:]]*pre-install-cmd:/d' "\$COMPOSE_FILE"
    fi
    
    # Step 4: Wait for container to be created
    echo "ðŸ” Step 4: Waiting for container to be created..."
    counter=0
    max_wait=60
    
    while [ \$counter -lt \$max_wait ]; do
      if docker ps -a --filter "name=\$CONTAINER_NAME" --format "{{.Names}}" | grep -q "^\$CONTAINER_NAME\$"; then
        echo "âœ… Container \$CONTAINER_NAME found after \$counter seconds"
        break
      fi
      echo "â³ Container not found yet... (\${counter}s/\${max_wait}s)"
      sleep 2
      counter=\$((counter + 2))
    done
    
    if ! docker ps -a --filter "name=\$CONTAINER_NAME" --format "{{.Names}}" | grep -q "^\$CONTAINER_NAME\$"; then
      echo "âŒ Container \$CONTAINER_NAME not found after \${max_wait}s"
      echo "ðŸ“‹ Available containers:"
      docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"
      exit 1
    fi

    # Adopt CasaOS compose project to avoid name conflicts (minimal change)
    PROJECT=\$(docker inspect -f '{{ index .Config.Labels "com.docker.compose.project" }}' "\$CONTAINER_NAME" 2>/dev/null || true)
    [ -z "\$PROJECT" ] && PROJECT=\$(basename "/DATA/AppData/casaos/apps/yunderagithubcompiler")
    echo "ðŸ”§ Using compose project: \$PROJECT"
    
    # Step 5: Restart the container with new compose file
    echo "ðŸ”„ Step 5: Restarting container with updated compose file..."
    
    cd "/DATA/AppData/casaos/apps/yunderagithubcompiler"
    if docker compose version >/dev/null 2>&1; then
      docker compose -p "\$PROJECT" up -d --force-recreate
    elif command -v docker-compose >/dev/null 2>&1; then
      docker-compose -p "\$PROJECT" up -d --force-recreate
    else
      echo "âš ï¸ No docker compose binary found; skipping restart"
      exit 0
    fi
    
    # Step 6: Verify the restart
    echo "âœ… Step 6: Verifying restart..."
    sleep 5
    
    NEW_STATUS=\$(docker ps --filter "name=\$CONTAINER_NAME" --format "{{.Status}}")
    if [ -n "\$NEW_STATUS" ]; then
      echo "âœ… Container \$CONTAINER_NAME is now running: \$NEW_STATUS"
      
      if docker exec "\$CONTAINER_NAME" test -S /var/run/docker.sock 2>/dev/null; then
        echo "âœ… Docker.sock is successfully mounted and accessible in container"
      else
        echo "âŒ Docker.sock is NOT accessible in container"
      fi
    else
      echo "âŒ Container \$CONTAINER_NAME is not running after restart"
    fi
    
    echo "ðŸ Watcher script completed at \$(date)"
    EOF
    
    # Make it executable and run in background
    chmod +x /tmp/yundera-docker-sock-fixer.sh
    nohup /tmp/yundera-docker-sock-fixer.sh > /tmp/yundera-docker-sock-fixer.log 2>&1 &
    
    echo "ðŸš€ Docker.sock fixer launched, check logs at /tmp/yundera-docker-sock-fixer.log"
